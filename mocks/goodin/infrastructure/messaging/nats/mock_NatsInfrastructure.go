// Code generated by mockery v2.43.2. DO NOT EDIT.

package nats_infra

import (
	context "context"

	jetstream "github.com/nats-io/nats.go/jetstream"
	mock "github.com/stretchr/testify/mock"

	nats "github.com/nats-io/nats.go"

	time "time"
)

// MockNatsInfrastructure is an autogenerated mock type for the NatsInfrastructure type
type MockNatsInfrastructure struct {
	mock.Mock
}

type MockNatsInfrastructure_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNatsInfrastructure) EXPECT() *MockNatsInfrastructure_Expecter {
	return &MockNatsInfrastructure_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with given fields:
func (_m *MockNatsInfrastructure) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNatsInfrastructure_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockNatsInfrastructure_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockNatsInfrastructure_Expecter) Close() *MockNatsInfrastructure_Close_Call {
	return &MockNatsInfrastructure_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockNatsInfrastructure_Close_Call) Run(run func()) *MockNatsInfrastructure_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNatsInfrastructure_Close_Call) Return(_a0 error) *MockNatsInfrastructure_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNatsInfrastructure_Close_Call) RunAndReturn(run func() error) *MockNatsInfrastructure_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CreateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *MockNatsInfrastructure) CreateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_CreateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConsumer'
type MockNatsInfrastructure_CreateConsumer_Call struct {
	*mock.Call
}

// CreateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *MockNatsInfrastructure_Expecter) CreateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *MockNatsInfrastructure_CreateConsumer_Call {
	return &MockNatsInfrastructure_CreateConsumer_Call{Call: _e.mock.On("CreateConsumer", ctx, stream, cfg)}
}

func (_c *MockNatsInfrastructure_CreateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *MockNatsInfrastructure_CreateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *MockNatsInfrastructure_CreateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *MockNatsInfrastructure_CreateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_CreateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *MockNatsInfrastructure_CreateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *MockNatsInfrastructure) CreateOrUpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_CreateOrUpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateConsumer'
type MockNatsInfrastructure_CreateOrUpdateConsumer_Call struct {
	*mock.Call
}

// CreateOrUpdateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *MockNatsInfrastructure_Expecter) CreateOrUpdateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *MockNatsInfrastructure_CreateOrUpdateConsumer_Call {
	return &MockNatsInfrastructure_CreateOrUpdateConsumer_Call{Call: _e.mock.On("CreateOrUpdateConsumer", ctx, stream, cfg)}
}

func (_c *MockNatsInfrastructure_CreateOrUpdateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *MockNatsInfrastructure_CreateOrUpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *MockNatsInfrastructure_CreateOrUpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *MockNatsInfrastructure_CreateOrUpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *MockNatsInfrastructure) CreateOrUpdateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_CreateOrUpdateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateKeyValue'
type MockNatsInfrastructure_CreateOrUpdateKeyValue_Call struct {
	*mock.Call
}

// CreateOrUpdateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *MockNatsInfrastructure_Expecter) CreateOrUpdateKeyValue(ctx interface{}, cfg interface{}) *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call {
	return &MockNatsInfrastructure_CreateOrUpdateKeyValue_Call{Call: _e.mock.On("CreateOrUpdateKeyValue", ctx, cfg)}
}

func (_c *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *MockNatsInfrastructure_CreateOrUpdateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *MockNatsInfrastructure) CreateOrUpdateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_CreateOrUpdateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateObjectStore'
type MockNatsInfrastructure_CreateOrUpdateObjectStore_Call struct {
	*mock.Call
}

// CreateOrUpdateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *MockNatsInfrastructure_Expecter) CreateOrUpdateObjectStore(ctx interface{}, cfg interface{}) *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call {
	return &MockNatsInfrastructure_CreateOrUpdateObjectStore_Call{Call: _e.mock.On("CreateOrUpdateObjectStore", ctx, cfg)}
}

func (_c *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *MockNatsInfrastructure_CreateOrUpdateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateStream provides a mock function with given fields: ctx, cfg
func (_m *MockNatsInfrastructure) CreateOrUpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_CreateOrUpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateStream'
type MockNatsInfrastructure_CreateOrUpdateStream_Call struct {
	*mock.Call
}

// CreateOrUpdateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *MockNatsInfrastructure_Expecter) CreateOrUpdateStream(ctx interface{}, cfg interface{}) *MockNatsInfrastructure_CreateOrUpdateStream_Call {
	return &MockNatsInfrastructure_CreateOrUpdateStream_Call{Call: _e.mock.On("CreateOrUpdateStream", ctx, cfg)}
}

func (_c *MockNatsInfrastructure_CreateOrUpdateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *MockNatsInfrastructure_CreateOrUpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *MockNatsInfrastructure_CreateOrUpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_CreateOrUpdateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *MockNatsInfrastructure_CreateOrUpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConsumer provides a mock function with given fields: ctx, stream, consumer
func (_m *MockNatsInfrastructure) DeleteConsumer(ctx context.Context, stream string, consumer string) error {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConsumer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNatsInfrastructure_DeleteConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConsumer'
type MockNatsInfrastructure_DeleteConsumer_Call struct {
	*mock.Call
}

// DeleteConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *MockNatsInfrastructure_Expecter) DeleteConsumer(ctx interface{}, stream interface{}, consumer interface{}) *MockNatsInfrastructure_DeleteConsumer_Call {
	return &MockNatsInfrastructure_DeleteConsumer_Call{Call: _e.mock.On("DeleteConsumer", ctx, stream, consumer)}
}

func (_c *MockNatsInfrastructure_DeleteConsumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *MockNatsInfrastructure_DeleteConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNatsInfrastructure_DeleteConsumer_Call) Return(_a0 error) *MockNatsInfrastructure_DeleteConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNatsInfrastructure_DeleteConsumer_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNatsInfrastructure_DeleteConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function with given fields:
func (_m *MockNatsInfrastructure) Init() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNatsInfrastructure_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type MockNatsInfrastructure_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
func (_e *MockNatsInfrastructure_Expecter) Init() *MockNatsInfrastructure_Init_Call {
	return &MockNatsInfrastructure_Init_Call{Call: _e.mock.On("Init")}
}

func (_c *MockNatsInfrastructure_Init_Call) Run(run func()) *MockNatsInfrastructure_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNatsInfrastructure_Init_Call) Return(_a0 error) *MockNatsInfrastructure_Init_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNatsInfrastructure_Init_Call) RunAndReturn(run func() error) *MockNatsInfrastructure_Init_Call {
	_c.Call.Return(run)
	return _c
}

// OrderedConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *MockNatsInfrastructure) OrderedConsumer(ctx context.Context, stream string, cfg jetstream.OrderedConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for OrderedConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.OrderedConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.OrderedConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.OrderedConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_OrderedConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderedConsumer'
type MockNatsInfrastructure_OrderedConsumer_Call struct {
	*mock.Call
}

// OrderedConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.OrderedConsumerConfig
func (_e *MockNatsInfrastructure_Expecter) OrderedConsumer(ctx interface{}, stream interface{}, cfg interface{}) *MockNatsInfrastructure_OrderedConsumer_Call {
	return &MockNatsInfrastructure_OrderedConsumer_Call{Call: _e.mock.On("OrderedConsumer", ctx, stream, cfg)}
}

func (_c *MockNatsInfrastructure_OrderedConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.OrderedConsumerConfig)) *MockNatsInfrastructure_OrderedConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.OrderedConsumerConfig))
	})
	return _c
}

func (_c *MockNatsInfrastructure_OrderedConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *MockNatsInfrastructure_OrderedConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_OrderedConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.OrderedConsumerConfig) (jetstream.Consumer, error)) *MockNatsInfrastructure_OrderedConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: ctx, subject, payload, opts
func (_m *MockNatsInfrastructure) Publish(ctx context.Context, subject string, payload []byte, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, subject, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *jetstream.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, ...jetstream.PublishOpt) (*jetstream.PubAck, error)); ok {
		return rf(ctx, subject, payload, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, ...jetstream.PublishOpt) *jetstream.PubAck); ok {
		r0 = rf(ctx, subject, payload, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []byte, ...jetstream.PublishOpt) error); ok {
		r1 = rf(ctx, subject, payload, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockNatsInfrastructure_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - payload []byte
//   - opts ...jetstream.PublishOpt
func (_e *MockNatsInfrastructure_Expecter) Publish(ctx interface{}, subject interface{}, payload interface{}, opts ...interface{}) *MockNatsInfrastructure_Publish_Call {
	return &MockNatsInfrastructure_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{ctx, subject, payload}, opts...)...)}
}

func (_c *MockNatsInfrastructure_Publish_Call) Run(run func(ctx context.Context, subject string, payload []byte, opts ...jetstream.PublishOpt)) *MockNatsInfrastructure_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *MockNatsInfrastructure_Publish_Call) Return(_a0 *jetstream.PubAck, _a1 error) *MockNatsInfrastructure_Publish_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_Publish_Call) RunAndReturn(run func(context.Context, string, []byte, ...jetstream.PublishOpt) (*jetstream.PubAck, error)) *MockNatsInfrastructure_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsync provides a mock function with given fields: subject, payload, opts
func (_m *MockNatsInfrastructure) PublishAsync(subject string, payload []byte, opts ...jetstream.PublishOpt) (jetstream.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishAsync")
	}

	var r0 jetstream.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)); ok {
		return rf(subject, payload, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...jetstream.PublishOpt) jetstream.PubAckFuture); ok {
		r0 = rf(subject, payload, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...jetstream.PublishOpt) error); ok {
		r1 = rf(subject, payload, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_PublishAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsync'
type MockNatsInfrastructure_PublishAsync_Call struct {
	*mock.Call
}

// PublishAsync is a helper method to define mock.On call
//   - subject string
//   - payload []byte
//   - opts ...jetstream.PublishOpt
func (_e *MockNatsInfrastructure_Expecter) PublishAsync(subject interface{}, payload interface{}, opts ...interface{}) *MockNatsInfrastructure_PublishAsync_Call {
	return &MockNatsInfrastructure_PublishAsync_Call{Call: _e.mock.On("PublishAsync",
		append([]interface{}{subject, payload}, opts...)...)}
}

func (_c *MockNatsInfrastructure_PublishAsync_Call) Run(run func(subject string, payload []byte, opts ...jetstream.PublishOpt)) *MockNatsInfrastructure_PublishAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *MockNatsInfrastructure_PublishAsync_Call) Return(_a0 jetstream.PubAckFuture, _a1 error) *MockNatsInfrastructure_PublishAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_PublishAsync_Call) RunAndReturn(run func(string, []byte, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)) *MockNatsInfrastructure_PublishAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncComplete provides a mock function with given fields:
func (_m *MockNatsInfrastructure) PublishAsyncComplete() <-chan struct{} {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublishAsyncComplete")
	}

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// MockNatsInfrastructure_PublishAsyncComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncComplete'
type MockNatsInfrastructure_PublishAsyncComplete_Call struct {
	*mock.Call
}

// PublishAsyncComplete is a helper method to define mock.On call
func (_e *MockNatsInfrastructure_Expecter) PublishAsyncComplete() *MockNatsInfrastructure_PublishAsyncComplete_Call {
	return &MockNatsInfrastructure_PublishAsyncComplete_Call{Call: _e.mock.On("PublishAsyncComplete")}
}

func (_c *MockNatsInfrastructure_PublishAsyncComplete_Call) Run(run func()) *MockNatsInfrastructure_PublishAsyncComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNatsInfrastructure_PublishAsyncComplete_Call) Return(_a0 <-chan struct{}) *MockNatsInfrastructure_PublishAsyncComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNatsInfrastructure_PublishAsyncComplete_Call) RunAndReturn(run func() <-chan struct{}) *MockNatsInfrastructure_PublishAsyncComplete_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncPending provides a mock function with given fields:
func (_m *MockNatsInfrastructure) PublishAsyncPending() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublishAsyncPending")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockNatsInfrastructure_PublishAsyncPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncPending'
type MockNatsInfrastructure_PublishAsyncPending_Call struct {
	*mock.Call
}

// PublishAsyncPending is a helper method to define mock.On call
func (_e *MockNatsInfrastructure_Expecter) PublishAsyncPending() *MockNatsInfrastructure_PublishAsyncPending_Call {
	return &MockNatsInfrastructure_PublishAsyncPending_Call{Call: _e.mock.On("PublishAsyncPending")}
}

func (_c *MockNatsInfrastructure_PublishAsyncPending_Call) Run(run func()) *MockNatsInfrastructure_PublishAsyncPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNatsInfrastructure_PublishAsyncPending_Call) Return(_a0 int) *MockNatsInfrastructure_PublishAsyncPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNatsInfrastructure_PublishAsyncPending_Call) RunAndReturn(run func() int) *MockNatsInfrastructure_PublishAsyncPending_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsg provides a mock function with given fields: ctx, msg, opts
func (_m *MockNatsInfrastructure) PublishMsg(ctx context.Context, msg *nats.Msg, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsg")
	}

	var r0 *jetstream.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) (*jetstream.PubAck, error)); ok {
		return rf(ctx, msg, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) *jetstream.PubAck); ok {
		r0 = rf(ctx, msg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) error); ok {
		r1 = rf(ctx, msg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_PublishMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsg'
type MockNatsInfrastructure_PublishMsg_Call struct {
	*mock.Call
}

// PublishMsg is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *nats.Msg
//   - opts ...jetstream.PublishOpt
func (_e *MockNatsInfrastructure_Expecter) PublishMsg(ctx interface{}, msg interface{}, opts ...interface{}) *MockNatsInfrastructure_PublishMsg_Call {
	return &MockNatsInfrastructure_PublishMsg_Call{Call: _e.mock.On("PublishMsg",
		append([]interface{}{ctx, msg}, opts...)...)}
}

func (_c *MockNatsInfrastructure_PublishMsg_Call) Run(run func(ctx context.Context, msg *nats.Msg, opts ...jetstream.PublishOpt)) *MockNatsInfrastructure_PublishMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *MockNatsInfrastructure_PublishMsg_Call) Return(_a0 *jetstream.PubAck, _a1 error) *MockNatsInfrastructure_PublishMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_PublishMsg_Call) RunAndReturn(run func(context.Context, *nats.Msg, ...jetstream.PublishOpt) (*jetstream.PubAck, error)) *MockNatsInfrastructure_PublishMsg_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsgAsync provides a mock function with given fields: msg, opts
func (_m *MockNatsInfrastructure) PublishMsgAsync(msg *nats.Msg, opts ...jetstream.PublishOpt) (jetstream.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsgAsync")
	}

	var r0 jetstream.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)); ok {
		return rf(msg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...jetstream.PublishOpt) jetstream.PubAckFuture); ok {
		r0 = rf(msg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...jetstream.PublishOpt) error); ok {
		r1 = rf(msg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_PublishMsgAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsgAsync'
type MockNatsInfrastructure_PublishMsgAsync_Call struct {
	*mock.Call
}

// PublishMsgAsync is a helper method to define mock.On call
//   - msg *nats.Msg
//   - opts ...jetstream.PublishOpt
func (_e *MockNatsInfrastructure_Expecter) PublishMsgAsync(msg interface{}, opts ...interface{}) *MockNatsInfrastructure_PublishMsgAsync_Call {
	return &MockNatsInfrastructure_PublishMsgAsync_Call{Call: _e.mock.On("PublishMsgAsync",
		append([]interface{}{msg}, opts...)...)}
}

func (_c *MockNatsInfrastructure_PublishMsgAsync_Call) Run(run func(msg *nats.Msg, opts ...jetstream.PublishOpt)) *MockNatsInfrastructure_PublishMsgAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *MockNatsInfrastructure_PublishMsgAsync_Call) Return(_a0 jetstream.PubAckFuture, _a1 error) *MockNatsInfrastructure_PublishMsgAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_PublishMsgAsync_Call) RunAndReturn(run func(*nats.Msg, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)) *MockNatsInfrastructure_PublishMsgAsync_Call {
	_c.Call.Return(run)
	return _c
}

// Request provides a mock function with given fields: subj, data, timeout
func (_m *MockNatsInfrastructure) Request(subj string, data []byte, timeout time.Duration) (*nats.Msg, error) {
	ret := _m.Called(subj, data, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Request")
	}

	var r0 *nats.Msg
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, time.Duration) (*nats.Msg, error)); ok {
		return rf(subj, data, timeout)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, time.Duration) *nats.Msg); ok {
		r0 = rf(subj, data, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Msg)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, time.Duration) error); ok {
		r1 = rf(subj, data, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_Request_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Request'
type MockNatsInfrastructure_Request_Call struct {
	*mock.Call
}

// Request is a helper method to define mock.On call
//   - subj string
//   - data []byte
//   - timeout time.Duration
func (_e *MockNatsInfrastructure_Expecter) Request(subj interface{}, data interface{}, timeout interface{}) *MockNatsInfrastructure_Request_Call {
	return &MockNatsInfrastructure_Request_Call{Call: _e.mock.On("Request", subj, data, timeout)}
}

func (_c *MockNatsInfrastructure_Request_Call) Run(run func(subj string, data []byte, timeout time.Duration)) *MockNatsInfrastructure_Request_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockNatsInfrastructure_Request_Call) Return(_a0 *nats.Msg, _a1 error) *MockNatsInfrastructure_Request_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_Request_Call) RunAndReturn(run func(string, []byte, time.Duration) (*nats.Msg, error)) *MockNatsInfrastructure_Request_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: subj, cb
func (_m *MockNatsInfrastructure) Subscribe(subj string, cb nats.MsgHandler) (*nats.Subscription, error) {
	ret := _m.Called(subj, cb)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, nats.MsgHandler) (*nats.Subscription, error)); ok {
		return rf(subj, cb)
	}
	if rf, ok := ret.Get(0).(func(string, nats.MsgHandler) *nats.Subscription); ok {
		r0 = rf(subj, cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, nats.MsgHandler) error); ok {
		r1 = rf(subj, cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNatsInfrastructure_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type MockNatsInfrastructure_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - subj string
//   - cb nats.MsgHandler
func (_e *MockNatsInfrastructure_Expecter) Subscribe(subj interface{}, cb interface{}) *MockNatsInfrastructure_Subscribe_Call {
	return &MockNatsInfrastructure_Subscribe_Call{Call: _e.mock.On("Subscribe", subj, cb)}
}

func (_c *MockNatsInfrastructure_Subscribe_Call) Run(run func(subj string, cb nats.MsgHandler)) *MockNatsInfrastructure_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(nats.MsgHandler))
	})
	return _c
}

func (_c *MockNatsInfrastructure_Subscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *MockNatsInfrastructure_Subscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNatsInfrastructure_Subscribe_Call) RunAndReturn(run func(string, nats.MsgHandler) (*nats.Subscription, error)) *MockNatsInfrastructure_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockNatsInfrastructure creates a new instance of MockNatsInfrastructure. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNatsInfrastructure(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNatsInfrastructure {
	mock := &MockNatsInfrastructure{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
